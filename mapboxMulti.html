<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Planting Map</title>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.css' rel='stylesheet' />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.1/css/all.css">
    <style>
        body {
            display: flex;
            font-family: 'Arial', sans-serif;
            margin:0px;
        }
        #sidebar {
            width: 300px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: #f4f4f4;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        #map {
            height: 100vh;
            flex-grow: 1;
        }
        .input-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
        }
        .input-group label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        button {
            margin-top:10px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #45a049;
        }

        /* Style for the custom checkbox */
        .custom-checkbox {
            display: inline-block;
            position: relative;
            padding-left: 25px;
            cursor: pointer;
            font-size: 16px;
            line-height: 20px;
            user-select: none;
        }

        /* Hide the default checkbox */
        .custom-checkbox input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        /* Create a custom checkbox */
        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: #eee;
            border-radius: 4px;
        }

        /* When the checkbox is checked, add a blue background */
        .custom-checkbox input:checked ~ .checkmark {
            background-color: #2196F3;
        }

        /* Create the checkmark/indicator (hidden when not checked) */
        .checkmark:after {
            content: "\f00c"; /* Correct code for FontAwesome checkmark */
            font-family: "Font Awesome 5 Free";
            font-weight: 900; /* FontAwesome 5 requires explicit font-weight for solid icons */
            position: absolute;
            display: none;
            color: white;
            top: -2px;
            left: 5px;
            font-size: 14px;
        }

        /* Show the checkmark when checked */
        .custom-checkbox input:checked ~ .checkmark:after {
            display: block;
        }

        /* Style the checkmark/indicator */
        .custom-checkbox .checkmark:after {
            left: 5px;
            top: 0px;
        }

        .district-label-tooltip {
            background-color: transparent;
            border: none;
            box-shadow: none;
            font-size: 14px;
            color: black;
            text-align: center;
            padding: 0;
            pointer-events: none;
            z-index: 1000000;
        }

        .district-label {
            font-weight: normal;
            z-index: 1000000;
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <h2><i class="fas fa-tree"></i> Tree Planting Parameters</h2>
        <form id="parametersForm">
            <div class="input-group">
                <label for="boroSelect">Select Borough:</label>
                <select id="boroSelect" data-current="">
                    <!-- Options will be dynamically added -->
                </select>
            </div>

            <div class="input-group">
                <label for="totalTrees">Total Trees:</label>
                <input type="number" id="totalTrees" name="totalTrees" value="100">
            </div>
            <div class="input-group">
                <label for="coolingEffect">Cooling Effect:</label>
                <input type="number" id="coolingEffect" name="coolingEffect" step="1" value="1">
            </div>
            <div class="input-group">
                <label for="coolingDistance">Cooling Distance (meters):</label>
                <input type="number" id="coolingDistance" name="coolingDistance" value="500">
            </div>
            <button type="button" onclick="updateTreePlanting()">Update Tree Planting</button>
            <button type="button" onclick="clearPlantedTrees()">Clear Planted Trees</button>
            <h4 id="results">...</h4>

            <div class="input-group">
                <label>Effect Type:</label>
                <label><input type="radio" name="effectType" value="binary" onchange="toggleGaussianSettings()" checked> Binary</label>
                <label><input type="radio" name="effectType" value="gaussian" onchange="toggleGaussianSettings()"> Gaussian</label>
            </div>
            <div id="gaussianSettings" style="display: none;">
                <div class="input-group">
                    <label for="gaussianSigma">Gaussian Sigma:</label>
                    <input type="number" id="gaussianSigma" name="gaussianSigma" step="0.1" value="1">
                </div>
                <div class="input-group">
                    <label for="gaussianAmplitude">Gaussian Amplitude:</label>
                    <input type="number" id="gaussianAmplitude" name="gaussianAmplitude" step="0.1" value="1">
                </div>
            </div>

            <label class="custom-checkbox">Show Heat Index
                <input type="checkbox" id="heatIndexToggle" name="heatIndexToggle" onchange="toggleHeatIndex()" checked>
                <span class="checkmark"></span>
            </label>
            <div id="heatIndexSettings" style="display: none;">
                <div class="input-group" style="display: none;">
                    <label for="heatIndexScale">Heat Index Scale:</label>
                    <input type="range" id="heatIndexScale" name="heatIndexScale" min="0.1" max="10" step="0.1" value="1">
                </div>
            </div>

            <!-- Tree Data Toggle and Settings -->
            <label class="custom-checkbox">View Tree Data
                <input type="checkbox" id="treeToggleView" name="treeToggleView" onchange="toggleTreeSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="treeSettings" style="display: none;">
                <label class="custom-checkbox">Show Tree Radius
                    <input type="checkbox" id="treeRadiusToggle" name="treeRadiusToggle" onchange="toggleTreeRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="treeCoolingEffect">Tree Cooling Effect:</label>
                    <input type="number" id="treeCoolingEffect" name="treeCoolingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="treeCoolingDistance">Tree Cooling Distance (meters):</label>
                    <input type="number" id="treeCoolingDistance" name="treeCoolingDistance" value="20">
                </div>
            </div>

            <!-- School Data Toggle and Settings -->
            <label class="custom-checkbox">View School Data
                <input type="checkbox" id="schoolToggleView" name="schoolToggleView" onchange="toggleSchoolSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="schoolSettings" style="display: none;">
                <label class="custom-checkbox">Show School Radius
                    <input type="checkbox" id="schoolRadiusToggle" name="schoolRadiusToggle" onchange="toggleSchoolRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="schoolHeatingEffect">School Heating Effect:</label>
                    <input type="number" id="schoolHeatingEffect" name="schoolHeatingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="schoolHeatingDistance">School Heating Distance (meters):</label>
                    <input type="number" id="schoolHeatingDistance" name="schoolHeatingDistance" value="500">
                </div>
            </div>

            <!-- Facility Data Toggle and Settings -->
            <label class="custom-checkbox">View Facility Data
                <input type="checkbox" id="facilityToggleView" name="facilityToggleView" onchange="toggleFacilitySettings()">
                <span class="checkmark"></span>
            </label>
            <div id="facilitySettings" style="display: none;">
                <label class="custom-checkbox">Show Facility Radius
                    <input type="checkbox" id="facilityRadiusToggle" name="facilityRadiusToggle" onchange="toggleFacilityRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="facilityHeatingEffect">Facility Heating Effect:</label>
                    <input type="number" id="facilityHeatingEffect" name="facilityHeatingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="facilityHeatingDistance">Facility Heating Distance (meters):</label>
                    <input type="number" id="facilityHeatingDistance" name="facilityHeatingDistance" value="500">
                </div>
            </div>

            <!-- Add the following in the sidebar section of the HTML -->
            <label class="custom-checkbox">View Street Data
                <input type="checkbox" id="streetToggleView" name="streetToggleView" onchange="toggleStreetSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="streetSettings" style="display: none;">
                <label class="custom-checkbox">Show Street Buffer
                    <input type="checkbox" id="streetBufferToggle" name="streetBufferToggle" onchange="toggleStreetBuffer()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="streetEffect">Street Effect:</label>
                    <input type="number" id="streetEffect" name="streetEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="streetBufferDistance">Street Buffer Distance (meters):</label>
                    <input type="number" id="streetBufferDistance" name="streetBufferDistance" value="5">
                </div>
                <div class="input-group">
                    <label for="streetWeightField">Street Weight Field:</label>
                    <select id="streetWeightField" name="streetWeightField">
                        <option value="SHAPE_Length">SHAPE_Length</option>
                        <option value="StreetWidth_Min">StreetWidth_Min</option>
                        <option value="StreetWidth_Max">StreetWidth_Max</option>
                        <option value="BikeLane">BikeLane</option>
                        <option value="Number_Travel_Lanes">Number_Travel_Lanes</option>
                        <option value="Number_Park_Lanes">Number_Park_Lanes</option>
                        <option value="Number_Total_Lanes">Number_Total_Lanes</option>
                        <option value="POSTED_SPEED">POSTED_SPEED</option>
                    </select>
                </div>
            </div>

            <label class="custom-checkbox">Planting View
                <input type="checkbox" id="plantingViewToggle" name="plantingViewToggle">
                <span class="checkmark"></span>
            </label>
        </form>
    </div>
    
    <div id="map"></div>

    <script src='https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="shp.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/rbush@3.0.1/rbush.min.js"></script>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoicnlhbmhsZXdpcyIsImEiOiJjbDhkcWZzcHowbGhiM3VrOWJ3ZmtzcnZyIn0.ipWAZK-oipctMjaHytOUKQ';

        var map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/light-v10',
            center: [-73.930188, 40.642935],
            zoom: 13
        });

        // load in treefolio84.geojson to originalGeoJsonData
        

        map.on('load', function () {

            map.addSource('boroughs', {
                type: 'geojson',
                // data: 'boroboundaries.geojson' // Replace with the path to your GeoJSON file
                // boroboundaries_with_id.geojson
                data: 'boroboundaries_with_id.geojson'
            });

            // Add a layer to display the boroughs
            map.addLayer({
                id: 'boroughs',
                type: 'fill',
                source: 'boroughs',
                paint: {
                    // 'fill-color': '#888888',
                    'fill-opacity': 0
                }
            });

            // Add a layer for the borough borders
            map.addLayer({
                id: 'borough-borders',
                type: 'line',
                source: 'boroughs',
                paint: {
                    'line-color': '#000000',
                    'line-width': 2
                }
            });

            map.on('mousemove', 'boroughs', function(e) {
    if (e.features.length > 0) {
        var selectedBorough = document.getElementById('boroSelect').getAttribute('data-current');
        var hoveredBorough = e.features[0].properties.boro_cd;

        if (hoveredStateId !== null) {
            map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: false });
        }

        if (selectedBorough !== hoveredBorough.toString()) {
            hoveredStateId = e.features[0].id;
            map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: true });
        } else {
            hoveredStateId = null; // Reset if the hovered borough is the selected one
        }
    }
});

map.on('click', 'boroughs', function(e) {
    var selectedBorough = e.features[0].properties.boro_cd;

    // document.getElementById('boroSelect').setAttribute('data-current', selectedBorough);
    document.getElementById('boroSelect').value = selectedBorough;
    switchBorough();
    map.fitBounds(turf.bbox(e.features[0]));

    if (hoveredStateId !== null) {
        map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: false });
    }
    hoveredStateId = e.features[0].id;
    map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: true });
});

map.on('mouseleave', 'boroughs', function() {
    if (hoveredStateId !== null) {
        map.setFeatureState({ source: 'boroughs', id: hoveredStateId }, { hover: false });
    }
    hoveredStateId = null;
});

// Disable hover for the selected borough
map.on('mouseenter', 'boroughs', function(e) {
    var selectedBorough = document.getElementById('boroSelect').getAttribute('data-current');
    var hoveredBorough = e.features[0].properties.boro_cd;

    if (selectedBorough === hoveredBorough.toString()) {
        map.getCanvas().style.cursor = 'grab';
    } else {
        map.getCanvas().style.cursor = 'pointer';
    }
});

map.on('mouseleave', 'boroughs', function() {
    map.getCanvas().style.cursor = '';
});


            // Add feature state for hover effect
            map.addLayer({
                id: 'boroughs-hover',
                type: 'fill',
                source: 'boroughs',
                layout: {},
                paint: {
                    'fill-color': '#627BC1',
                    'fill-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 0.6, 0]
                }
            });

            var hoveredStateId = null;

            // Add your GeoJSON source for tree markers
            map.addSource('treeMarkers', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            // Add a layer to display the tree markers
            map.addLayer({
                id: 'treeMarkers',
                type: 'circle',
                source: 'treeMarkers',
                paint: {
                    'circle-radius': 5,
                    'circle-color': '#ADD8E6',
                    // green instead
                    'circle-color': '#008000',
                    'circle-opacity': 0.8
                }
            });
            // Add your GeoJSON source
            map.addSource('plantableAreas', {
                type: 'geojson',
                data: 'inputStreet.geojson'
            });

            // Add a layer to use the image to represent the data.
            map.addLayer({
                id: 'plantableAreas',
                type: 'fill',
                source: 'plantableAreas',
                layout: {},
                paint: {
                    'fill-color': [
                        'case',
                        ['==', ['get', 'canopy_type'], 'plantable'],
                        ['get', 'color'],
                        '#ffffff'
                    ],
                    'fill-opacity': 0.5
                }
            });

            map.addSource('schoolLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addSource('treeLayer', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    }
});

map.addLayer({
    id: 'schoolLayer',
    type: 'circle',
    source: 'schoolLayer',
    paint: {
        'circle-radius': 5,
        'circle-color': '#FF0000',
        'circle-opacity': 0.8
    }
});

map.addLayer({
    id: 'treeLayer',
    type: 'circle',
    source: 'treeLayer',
    paint: {
        'circle-radius': 5,
        'circle-color': '#00FF00',
        'circle-opacity': 0.8
    }
});


    // Add event listeners for school settings
    document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
    document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
        updateSchoolHeatingDistance();
        updatePlantableAreaColors();
    });
    document.getElementById('schoolToggleView').addEventListener('change', toggleSchoolSettings);
    document.getElementById('schoolRadiusToggle').addEventListener('change', toggleSchoolRadius);
            // Call the function to update tree planting parameters
            // updateTreePlanting();
        });

        var currentGeoJsonLayer = null;

        // Make a layer for the trees, schools, and facilities using Mapbox GL JS
        // var newLayer = new mapboxgl.LayerGroup(); // Initialize with an empty layer group
        

        function displayGeoJson(geojsonData) {
            if (map.getSource('plantableAreas')) {
        map.getSource('plantableAreas').setData(geojsonData);
    } else {
        console.error('Source "plantableAreas" is not defined');
    }
        }

        function updateTreePlanting() {
            var totalTrees = parseInt(document.getElementById('totalTrees').value);
            var coolingEffect = parseFloat(document.getElementById('coolingEffect').value);
            var coolingDistance = parseInt(document.getElementById('coolingDistance').value);

            // Clear existing tree markers
            clearMapLayers();

            // Example values for schoolEffect and schoolDistance, replace with actual input retrieval
            let schoolEffect = parseFloat(document.getElementById('schoolHeatingEffect').value);
            let schoolDistance = parseInt(document.getElementById('schoolHeatingDistance').value);

            // Example values for treeEffect and treeDistance, replace with actual input retrieval
            let treeEffect = parseFloat(document.getElementById('treeCoolingEffect').value);
            let treeDistance = parseInt(document.getElementById('treeCoolingDistance').value);

            // Example values for facilityEffect and facilityDistance, replace with actual input retrieval
            let facilityEffect = parseFloat(document.getElementById('facilityHeatingEffect').value);
            let facilityDistance = parseInt(document.getElementById('facilityHeatingDistance').value);

            let streetEffect = parseFloat(document.getElementById('streetEffect').value);
            let streetBufferDistance = parseInt(document.getElementById('streetBufferDistance').value);
            let streetWeightField = document.getElementById('streetWeightField').value;

            // Pass the additional parameters for streets to the planting function
            PlantTrees(originalGeoJsonData, totalTrees, coolingEffect, coolingDistance, schoolEffect, schoolDistance, treeEffect, treeDistance, facilityEffect, facilityDistance, streetEffect, streetBufferDistance, streetWeightField);
        }

        function clearMapLayers() {
    console.log('Clearing map layers');

    schoolCircles.forEach(function(schoolCircle) {
        console.log('Removing school circle layer:', schoolCircle);
        if (map.getLayer(schoolCircle.id)) {
            map.removeLayer(schoolCircle.id);
        }
        if (map.getSource(schoolCircle.id)) {
            map.removeSource(schoolCircle.id);
        }

        const pointId = 'schoolPoint_' + schoolCircle.id;
        if (map.getLayer(pointId)) {
            map.removeLayer(pointId);
        }
        if (map.getSource(pointId)) {
            map.removeSource(pointId);
        }
    });

    schoolCircles = [];
}

        function clearPlantedTrees() {
                // Clear the treeMarkers source
    if (map.getSource('treeMarkers')) {
        map.getSource('treeMarkers').setData({
            type: 'FeatureCollection',
            features: []
        });
    }
            document.getElementById('results').innerText = 'Cleared all planted trees.';
        }


        function calculateCentroid(geometry) {
            let centroid = [0, 0];
            let totalPoints = 0;

            if (geometry.type === "Polygon") {
                geometry.coordinates[0].forEach(coord => {
                    centroid[0] += coord[0]; // longitude
                    centroid[1] += coord[1]; // latitude
                    totalPoints++;
                });
            } else if (geometry.type === "MultiPolygon") {
                geometry.coordinates.forEach(polygon => {
                    let polygonCentroid = [0, 0];
                    let polygonPoints = 0;
                    polygon[0].forEach(coord => { // Only using the first ring
                        polygonCentroid[0] += coord[0];
                        polygonCentroid[1] += coord[1];
                        polygonPoints++;
                    });
                    centroid[0] += polygonCentroid[0] / polygonPoints; // Average for this polygon
                    centroid[1] += polygonCentroid[1] / polygonPoints;
                    totalPoints += 1; // We're averaging centroids, so each polygon counts as one "point"
                });
            }

            centroid[0] /= totalPoints; // Final average
            centroid[1] /= totalPoints;
            return [centroid[1], centroid[0]]; // Mapbox uses [lat, lng] format
        }

        function PlantTrees(originalGeoJsonData, totalTrees, coolingEffect, coolingDistance, schoolEffect, schoolDistance, treeEffect, treeDistance, facilityEffect, facilityDistance, streetEffect, streetBufferDistance, streetWeightField) {
            let geojsonData = JSON.parse(JSON.stringify(originalGeoJsonData));

            // Apply effects from schools and existing trees
            geojsonData = applySchoolEffect(geojsonData, schoolEffect, schoolDistance);
            geojsonData = applyTreeEffect(geojsonData, treeEffect, treeDistance);
            // geojsonData = applyFacilityEffect(geojsonData, facilityEffect, facilityDistance);
            // geojsonData = applyStreetEffect(geojsonData, streetEffect, streetBufferDistance, streetWeightField);

            let plantableAreas = geojsonData.features.filter(feature => feature.properties.canopy_type === 'plantable');

            let treesPlanted = 0;

            while (treesPlanted < totalTrees && plantableAreas.length > 0) {
                // Calculate the combined mean for each plantable area
                plantableAreas.forEach(area => {
                    // if heat index is on, add the heat index to the mean
                    if (showHeatIndex) {
                        area.properties._combinedMean = (area.properties._mean || 0) + (area.properties._schoolmean || 0) + (area.properties._treemean || 0) + (area.properties._facilitymean || 0);
                    } else {
                        area.properties._combinedMean = (area.properties._schoolmean || 0) + (area.properties._treemean || 0) + (area.properties._facilitymean || 0);
                    }
                });

                // Sort plantable areas by _combinedMean property in descending order
                plantableAreas.sort((a, b) => b.properties._combinedMean - a.properties._combinedMean);

                const plantingArea = plantableAreas[0];

                const centroid = calculateCentroid(plantingArea.geometry);
                placeTreeOnMap(centroid);
                treesPlanted++;

                // Apply cooling effect to the planted area if applicable
                if (coolingEffect > 0) {
                    plantingArea.properties._treemean = (plantingArea.properties._treemean || 0) - coolingEffect;
                    if (document.getElementById('plantingViewToggle').checked) {
                        plantingArea.properties._displayMean = (plantingArea.properties._mean || 0) + (plantingArea.properties._schoolmean || 0) + plantingArea.properties._treemean;
                    }
                }

                // Filter and adjust remaining plantable areas considering cooling effect and distance
                plantableAreas = plantableAreas.slice(1).filter(area => {
                    const areaCentroid = calculateCentroid(area.geometry);
                    const distance = getDistance(centroid[0], centroid[1], areaCentroid[0], areaCentroid[1]);
                    if (coolingDistance > 0 && distance <= coolingDistance && coolingEffect > 0) {
                        area.properties._treemean = (area.properties._treemean || 0) - coolingEffect * (coolingDistance - distance) / coolingDistance;
                    }
                    return area.properties._combinedMean > 0;
                });
            }

            if (treesPlanted < totalTrees) {
                console.log(`Planted ${treesPlanted} trees. Ran out of suitable planting areas.`);
                document.getElementById('results').innerText = `Planted ${treesPlanted} trees. Ran out of suitable planting areas.`;
            } else {
                console.log(`Successfully planted all ${totalTrees} trees.`);
                document.getElementById('results').innerText = `Successfully planted all ${totalTrees} trees.`;
            }

            if (document.getElementById('plantingViewToggle').checked) {
                calculateMinMaxMean(geojsonData);
                updateMeanColors(geojsonData);
                displayGeoJson(geojsonData);
            }
        }

        function placeTreeOnMap(centroid) {
            const treeMarkerSource = map.getSource('treeMarkers');
            const newFeature = {
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [centroid[1], centroid[0]]
                },
                properties: {}
            };

            const data = treeMarkerSource._data; // Access the current data
            data.features.push(newFeature); // Add the new feature
            treeMarkerSource.setData(data); // Update the source with the new data
        }


        function getDistance(lat1, lon1, lat2, lon2) {
            var R = 6371e3; // Earth's radius in meters
            var φ1 = lat1 * Math.PI / 180;
            var φ2 = lat2 * Math.PI / 180;
            var Δφ = (lat2 - lat1) * Math.PI / 180;
            var Δλ = (lon2 - lon1) * Math.PI / 180;

            var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                    Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // in meters
        }

        function getColor(heatIndex, scale) {
            console.log("max and min mean", maxMean, minMean);
            const range = maxMean - minMean;
            const normalizedIndex = (heatIndex - minMean) / range;
            const scaledIndex = Math.pow(normalizedIndex, scale);

            // Interpolate between green (0), orange (0.5), and red (1)
            if (scaledIndex < 0.5) {
                // Mix between green and orange
                const mix = scaledIndex * 2;
                return mixColor('#008000', '#ff8c00', mix);
            } else {
                // Mix between orange and red
                const mix = (scaledIndex - 0.5) * 2;
                return mixColor('#ff8c00', '#ff0000', mix);
            }
        }

        var showHeatIndex = false;
        var heatIndexScale = 1;

        function toggleHeatIndex() {
            showHeatIndex = document.getElementById('heatIndexToggle').checked;
            console.log("Show heat index:", showHeatIndex);
            document.getElementById('heatIndexSettings').style.display = showHeatIndex ? 'block' : 'none';
            updatePlantableAreaColors();
        }

        function mixColor(color1, color2, weight) {
            var color1Rgb = hexToRgb(color1),
                color2Rgb = hexToRgb(color2),
                r = Math.round(mix(color1Rgb.r, color2Rgb.r, weight)),
                g = Math.round(mix(color1Rgb.g, color2Rgb.g, weight)),
                b = Math.round(mix(color1Rgb.b, color2Rgb.b, weight));
            return rgbToHex(r, g, b);
        }

        function mix(start, end, weight) {
            return start + (end - start) * weight;
        }

        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        var originalGeoJsonData;

        var minMean, maxMean;

        function calculateMinMaxMean(geojsonData) {
            var means = geojsonData.features.map(feature => {
                if (feature.properties.canopy_type === 'plantable') {
                    return feature.properties._displayMean;
                }
            }).filter(mean => mean !== undefined);

            minMean = Math.min(...means);
            maxMean = Math.max(...means);
            if (minMean === maxMean) {
                minMean = 0;
                maxMean = 1;
            }
            if (minMean === Infinity) {
                minMean = 0;
                maxMean = 1;
            }
            console.log("Calculated min and max mean values:", minMean, maxMean);
        }

        function drawLinesToClosestSchoolFromLayer() {
            originalGeoJsonData.features.forEach(plantableArea => {
                if (plantableArea.properties.canopy_type === 'plantable') {
                    const plantableCentroid = calculateCentroid(plantableArea.geometry);

                    let closestSchoolPoint = null;
                    let minDistance = Infinity;

                    schoolLayer.eachLayer(function(layer) {
                        let schoolPoint;
                        if (layer.feature && layer.feature.geometry) {
                            if (layer.feature.geometry.type === 'MultiPoint') {
                                const firstPointCoords = layer.feature.geometry.coordinates[0];
                                schoolPoint = [firstPointCoords[1], firstPointCoords[0]]; // Correct [lat, lng] order for Mapbox
                            } else {
                                schoolPoint = [layer.feature.geometry.coordinates[1], layer.feature.geometry.coordinates[0]];
                            }
                        } else if (layer.getLatLng) {
                            let latLng = layer.getLatLng();
                            schoolPoint = [latLng.lat, latLng.lng];
                        } else {
                            console.log('Unknown layer type or geometry not defined');
                            return;
                        }

                        const distance = getDistance(plantableCentroid[0], plantableCentroid[1], schoolPoint[0], schoolPoint[1]);
                        if (distance < minDistance) {
                            closestSchoolPoint = schoolPoint;
                            minDistance = distance;
                        }
                    });

                    if (closestSchoolPoint) {
                        map.addLayer({
                            id: 'line' + Math.random(),
                            type: 'line',
                            source: {
                                type: 'geojson',
                                data: {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: [
                                            [plantableCentroid[1], plantableCentroid[0]],
                                            closestSchoolPoint
                                        ]
                                    }
                                }
                            },
                            layout: {
                                'line-join': 'round',
                                'line-cap': 'round'
                            },
                            paint: {
                                'line-color': 'blue',
                                'line-width': 1,
                                'line-opacity': 0.5
                            }
                        });
                    }
                }
            });
        }

        function updatePlantableAreaColors() {
            let geojsonData = JSON.parse(JSON.stringify(originalGeoJsonData));

            geojsonData.features.forEach(feature => {
                if (feature.properties.canopy_type === 'plantable') {
                    feature.properties._heatIndex = 0;
                    feature.properties._displayMean = 0;
                    feature.properties._schoolmean = 0;
                    feature.properties._treemean = 0;
                    feature.properties._facilitymean = 0;
                    feature.properties._streetmean = 0;
                    feature.properties.color = '#008000';
                }
            });

            let schoolEffect = parseFloat(document.getElementById('schoolHeatingEffect').value);
            let schoolDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
            let treeEffect = parseFloat(document.getElementById('treeCoolingEffect').value);
            let treeDistance = parseInt(document.getElementById('treeCoolingDistance').value);
            let streetEffect = parseFloat(document.getElementById('streetEffect').value);
            let streetBufferDistance = parseInt(document.getElementById('streetBufferDistance').value);
            let streetWeightField = document.getElementById('streetWeightField').value;

            geojsonData = applySchoolEffect(geojsonData, schoolEffect, schoolDistance);
            geojsonData = applyTreeEffect(geojsonData, treeEffect, treeDistance);
            let facilityEffect = parseFloat(document.getElementById('facilityHeatingEffect').value);
            let facilityDistance = parseInt(document.getElementById('facilityHeatingDistance').value);
            // geojsonData = applyFacilityEffect(geojsonData, facilityEffect, facilityDistance);
            // geojsonData = applyStreetEffect(geojsonData, streetEffect, streetBufferDistance, streetWeightField);

            geojsonData.features.forEach(feature => {
                if (feature.properties.canopy_type === 'plantable') {
                    if (document.getElementById('heatIndexToggle').checked) {
                        feature.properties._displayMean = feature.properties._mean + (feature.properties._schoolmean || 0) + (feature.properties._treemean || 0) + (feature.properties._facilitymean || 0) + (feature.properties._streetmean || 0);
                    } else {
                        feature.properties._displayMean = (feature.properties._schoolmean || 0) + (feature.properties._treemean || 0) + (feature.properties._facilitymean || 0) + (feature.properties._streetmean || 0);
                    }
                }
            });

            calculateMinMaxMean(geojsonData);
            updateMeanColors(geojsonData);
            displayGeoJson(geojsonData);
        }

        function getMeanColor(mean) {
            const normalizedMean = (mean - minMean) / (maxMean - minMean);
            if (normalizedMean < 0.5) {
                const mix = normalizedMean * 2;
                return mixColor('#008000', '#ff8c00', mix);
            } else {
                const mix = (normalizedMean - 0.5) * 2;
                return mixColor('#ff8c00', '#ff0000', mix);
            }
        }

        function updateMeanColors(geojsonData) {
            geojsonData.features.forEach(feature => {
                if (feature.properties.canopy_type === 'plantable') {
                    const mean = feature.properties._displayMean;
                    feature.properties.color = getMeanColor(mean);
                }
            });
        }

        function applySchoolEffect(geojsonData, schoolEffect, schoolDistance) {
    if (!document.getElementById('schoolToggleView').checked) {
        return geojsonData;
    }

    var effectType = document.querySelector('input[name="effectType"]:checked').value;
    var sigma = parseFloat(document.getElementById('gaussianSigma').value);
    var amplitude = parseFloat(document.getElementById('gaussianAmplitude').value);
    
    var schoolLayer = map.getSource('schoolLayer')._data;

    geojsonData.features.forEach(plantableArea => {
        if (plantableArea.properties.canopy_type === 'plantable') {
            const plantableCentroid = calculateCentroid(plantableArea.geometry);

            schoolLayer.features.forEach(schoolFeature => {
                const schoolPoint = schoolFeature.geometry.coordinates;

                const distance = getDistance(plantableCentroid[0], plantableCentroid[1], schoolPoint[1], schoolPoint[0]);
                if (effectType === 'binary') {
                    if (distance <= schoolDistance) {
                        if (!plantableArea.properties._schoolmean) {
                            plantableArea.properties._schoolmean = 0;
                        }
                        plantableArea.properties._schoolmean += schoolEffect + Math.random() * 5;
                    }
                } else if (effectType === 'gaussian') {
                    var weight = gaussianWeight(distance, schoolDistance, sigma, amplitude);
                    if (!plantableArea.properties._schoolmean) {
                        plantableArea.properties._schoolmean = 0;
                    }
                    plantableArea.properties._schoolmean += schoolEffect * weight;
                }
            });
        }
    });
    return geojsonData;
}


        function gaussianWeight(distance, effectDistance, sigma, amplitude) {
            var z = distance / (effectDistance * sigma);
            return amplitude * Math.exp(-0.5 * z * z);
        }

        function applyTreeEffect(geojsonData, treeEffect, treeDistance) {
            if (!document.getElementById('treeToggleView').checked) {
                return geojsonData;
            }

            var effectType = document.querySelector('input[name="effectType"]:checked').value;
            var sigma = parseFloat(document.getElementById('gaussianSigma').value);
            var amplitude = parseFloat(document.getElementById('gaussianAmplitude').value);

            var plantableIndex = new RBush();
            geojsonData.features.forEach(function(feature) {
                if (feature.properties.canopy_type === 'plantable') {
                    var bbox = turf.bbox(feature);
                    plantableIndex.insert({
                        minX: bbox[0],
                        minY: bbox[1],
                        maxX: bbox[2],
                        maxY: bbox[3],
                        feature: feature
                    });
                }
            });

            treeLayer.eachLayer(function(treeFeatureLayer) {
                treeFeatureLayer.eachLayer(function(layer) {
                    if (layer instanceof mapboxgl.Marker) {
                        const treePoint = layer.getLngLat();
                        const treePointGeoJSON = turf.point([treePoint.lng, treePoint.lat]);
                        const boundingBox = turf.bbox(turf.circle(treePointGeoJSON, treeDistance, { units: 'meters' }));

                        var plantablesInRange = plantableIndex.search({
                            minX: boundingBox[0],
                            minY: boundingBox[1],
                            maxX: boundingBox[2],
                            maxY: boundingBox[3]
                        });

                        plantablesInRange.forEach(function(plantable) {
                            var feature = plantable.feature;
                            var areaCentroid = turf.centroid(feature).geometry.coordinates;

                            var distance = turf.distance(treePointGeoJSON, turf.point(areaCentroid), { units: 'meters' });

                            if (effectType === 'binary') {
                                if (distance <= treeDistance) {
                                    if (!feature.properties._treemean) {
                                        feature.properties._treemean = 0;
                                    }
                                    feature.properties._treemean -= treeEffect;
                                }
                            } else if (effectType === 'gaussian') {
                                var weight = gaussianWeight(distance, treeDistance, sigma, amplitude);
                                if (!feature.properties._treemean) {
                                    feature.properties._treemean = 0;
                                }
                                feature.properties._treemean -= treeEffect * weight;
                            }
                        });
                    }
                });
            });

            return geojsonData;
        }

        function toggleTreeData() {
            var treeDataVisible = document.getElementById('treeToggleView').checked;
            var showTreeRadius = document.getElementById('treeRadiusToggle').checked;
            if (treeDataVisible) {
                if (!map.getSource('treeLayer')) {
                    $.getJSON('treefolio84.geojson', function(data) {
                        map.addSource('treeLayer', {
                            type: 'geojson',
                            data: data
                        });

                        map.addLayer({
                            id: 'treeLayer',
                            type: 'circle',
                            source: 'treeLayer',
                            paint: {
                                'circle-radius': 5,
                                'circle-color': '#ADD8E6',
                                'circle-opacity': 0.8
                            }
                        });

                        data.features.forEach(feature => {
                            const [lng, lat] = feature.geometry.coordinates;
                            const coolingDistance = parseInt(document.getElementById('treeCoolingDistance').value);
                            const effectCircle = turf.circle([lng, lat], coolingDistance, { units: 'meters' });

                            if (showTreeRadius) {
                                map.addSource('effectCircle' + Math.random(), {
                                    type: 'geojson',
                                    data: effectCircle
                                });

                                map.addLayer({
                                    id: 'effectCircle' + Math.random(),
                                    type: 'fill',
                                    source: 'effectCircle' + Math.random(),
                                    paint: {
                                        'fill-color': 'red',
                                        'fill-opacity': 0.5
                                    }
                                });
                            }
                        });

                        updatePlantableAreaColors();
                    });
                }
            } else {
                if (map.getSource('treeLayer')) {
                    map.removeLayer('treeLayer');
                    map.removeSource('treeLayer');
                    updatePlantableAreaColors();
                }
            }
        }

        function toggleTreeSettings() {
            toggleTreeData();
            var treeSettings = document.getElementById('treeSettings');
            var treeToggle = document.getElementById('treeToggleView').checked;
            treeSettings.style.display = treeToggle ? "block" : "none";
        }

        function toggleGaussianSettings() {
            var effectType = document.querySelector('input[name="effectType"]:checked').value;
            var gaussianSettings = document.getElementById('gaussianSettings');
            gaussianSettings.style.display = effectType === 'gaussian' ? 'block' : 'none';
        }

        document.getElementById('heatIndexScale').addEventListener('input', updatePlantableAreaColors);
        document.querySelectorAll('input[name="effectType"]').forEach(function(radio) {
            radio.addEventListener('change', updatePlantableAreaColors);
        });

        document.getElementById('gaussianSigma').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('gaussianAmplitude').addEventListener('change', updatePlantableAreaColors);

        document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });

        document.getElementById('treeCoolingDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });

        document.getElementById('treeCoolingEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('heatIndexScale').addEventListener('input', updatePlantableAreaColors);
        document.getElementById('schoolToggleView').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('treeToggleView').addEventListener('change', updatePlantableAreaColors);

        document.getElementById('plantingViewToggle').addEventListener('change', function() {
            updateTreePlanting();
            if (!document.getElementById('plantingViewToggle').checked) {
                updatePlantableAreaColors();
            }
        });

        document.getElementById('facilityHeatingEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('facilityHeatingDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });
        document.getElementById('facilityToggleView').addEventListener('change', updatePlantableAreaColors);

        document.getElementById('streetEffect').addEventListener('change', updatePlantableAreaColors);
        document.getElementById('streetBufferDistance').addEventListener('change', function() {
            updatePlantableAreaColors();
        });
        document.getElementById('streetWeightField').addEventListener('change', updatePlantableAreaColors);

        var boroughPattern = /boro_cd_(\d+)\.geojson/;

        function loadBoroughOptions() {
            $.ajax({
                url: "boros/",
                success: function(data) {
                    $(data).find("a:contains('.geojson')").each(function() {
                        var filename = $(this).attr("href");
                        var match = filename.match(boroughPattern);
                        if (match) {
                            var boroughCode = match[1];
                            var option = $("<option>").val(boroughCode).text("Borough " + boroughCode);
                            $("#boroSelect").append(option);
                        }
                    });
                    switchBorough();
                }
            });
        }
        async function loadGeoJson(url) {
    return new Promise((resolve, reject) => {
        $.getJSON(url, function(data) {
            resolve(data);
        }).fail(function() {
            reject(new Error('Failed to load GeoJSON data'));
        });
    });
}

async function switchBorough() {
    var selectedBorough = document.getElementById('boroSelect').value;
    var currentBorough = document.getElementById('boroSelect').getAttribute('data-current');

    if (selectedBorough === currentBorough) {
        return;
    }

    clearPlantedTrees();
    clearMapLayers();

    document.getElementById('boroSelect').setAttribute('data-current', selectedBorough);

    try {
        const [boroughData, schoolData] = await Promise.all([
            loadGeoJson(`./boros/boro_cd_${selectedBorough}.geojson`),
            loadGeoJson(`./borosSchools/boro_cd_${selectedBorough}.geojson`)
        ]);

        originalGeoJsonData = boroughData;
        calculateMinMaxMean(originalGeoJsonData);
        displayGeoJson(originalGeoJsonData);
        updatePlantableAreaColors();
        zoomToBorough(boroughData);

        map.setLayoutProperty('schoolLayer', 'visibility', 'none');
        map.getSource('schoolLayer').setData(schoolData);

        // If the school toggle is enabled, create the school circles
        if (document.getElementById('schoolToggleView').checked) {
            createSchoolCircles(schoolData);
            toggleSchoolRadius(); // Ensure the radius visibility is set correctly
        }
    } catch (error) {
        console.error('Error loading data:', error);
    }
}

        function zoomToBorough(geojsonData) {
        var bounds = turf.bbox(geojsonData);
        map.fitBounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]]); // Correct order: [latitude, longitude]
    }

// Define an array to store school circles and their IDs
var schoolCircles = [];

function createSchoolCircles(data) {
    const heatingDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
    const showSchoolRadius = document.getElementById('schoolRadiusToggle').checked;

    data.features.forEach(feature => {
        const coordinates = feature.geometry.coordinates;
        console.log('Creating circle for school with coordinates:', coordinates);
        const effectCircle = turf.circle(coordinates, heatingDistance, { units: 'meters' });
        const circleId = coordinates.join('_');

        if (map.getSource(circleId)) {
            map.getSource(circleId).setData(effectCircle);
        } else {
            schoolCircles.push({
                id: circleId,
                data: effectCircle
            });

            map.addSource(circleId, {
                type: 'geojson',
                data: effectCircle
            });

            map.addLayer({
                id: circleId,
                type: 'line',
                source: circleId,
                paint: {
                    'line-color': 'red',
                    'line-width': 2,
                    'line-opacity': 1
                },
                layout: {
                    'visibility': showSchoolRadius ? 'visible' : 'none'
                }
            });

            const pointId = 'schoolPoint_' + circleId;
            if (map.getSource(pointId)) {
                map.getSource(pointId).setData({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: coordinates
                    }
                });
            } else {
                map.addSource(pointId, {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: coordinates
                        }
                    }
                });

                map.addLayer({
                    id: pointId,
                    type: 'circle',
                    source: pointId,
                    paint: {
                        'circle-radius': 5,
                        'circle-color': 'red',
                        'circle-opacity': 1
                    }
                });
            }
        }
    });
}


// Function to update the school heating distance
function updateSchoolHeatingDistance() {
    const heatingDistance = parseInt(document.getElementById('schoolHeatingDistance').value);

    schoolCircles.forEach(circle => {
        if (circle.id.startsWith('schoolPoint_')) return; // Skip school points
        const coordinates = circle.id.split('_').map(coord => parseFloat(coord));
        console.log('Updating circle ID:', circle.id, 'with coordinates:', coordinates);

        // Ensure the coordinates are in the correct format
        if (Array.isArray(coordinates) && coordinates.length === 2 && typeof coordinates[0] === 'number' && typeof coordinates[1] === 'number') {
            const effectCircle = turf.circle(coordinates, heatingDistance, { units: 'meters' });
            map.getSource(circle.id).setData(effectCircle);
        } else {
            console.error('Invalid coordinates for turf.circle:', coordinates);
        }
    });

    updatePlantableAreaColors();
}

function toggleSchoolData() {
    var schoolDataVisible = document.getElementById('schoolToggleView').checked;
    var selectedBorough = document.getElementById('boroSelect').value;

    if (schoolDataVisible) {
        // Fetch and add the school data for the selected borough
        map.setLayoutProperty('schoolLayer', 'visibility', 'visible');
        schoolCircles.forEach(circle => {
            map.setLayoutProperty(circle.id, 'visibility', 'visible');
            const pointId = 'schoolPoint_' + circle.id;
            map.setLayoutProperty(pointId, 'visibility', 'visible');
        });
        $.getJSON('borosSchools/boro_cd_' + selectedBorough + '.geojson', function(data) {
            createSchoolCircles(data);
            updatePlantableAreaColors();
        });
    } else {
        map.setLayoutProperty('schoolLayer', 'visibility', 'none');
        schoolCircles.forEach(circle => {
            map.setLayoutProperty(circle.id, 'visibility', 'none');
            const pointId = 'schoolPoint_' + circle.id;
            map.setLayoutProperty(pointId, 'visibility', 'none');
        });
    }
}


// Function to toggle school radius visibility
function toggleSchoolRadius() {
    const showSchoolRadius = document.getElementById('schoolRadiusToggle').checked;
    console.log('Toggling school radius visibility:', showSchoolRadius);

    schoolCircles.forEach(circle => {
        console.log('Setting visibility for circle ID:', circle.id);
        map.setLayoutProperty(circle.id, 'visibility', showSchoolRadius ? 'visible' : 'none');
    });
}

// Function to toggle school settings
function toggleSchoolSettings() {
    toggleSchoolData();
    const schoolSettings = document.getElementById('schoolSettings');
    const schoolToggle = document.getElementById('schoolToggleView').checked;
    schoolSettings.style.display = schoolToggle ? 'block' : 'none';
}

// Add event listeners
document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
    updateSchoolHeatingDistance();
    updatePlantableAreaColors();
});
document.getElementById('schoolToggleView').addEventListener('change', toggleSchoolSettings);
document.getElementById('schoolRadiusToggle').addEventListener('change', toggleSchoolRadius);

// Initialize borough options and event listener for borough change
loadBoroughOptions();
document.getElementById('boroSelect').addEventListener('change', switchBorough);

// // Ensure school data is shown when switching boroughs if school data toggle is enabled
// function switchBorough() {
//     var selectedBorough = document.getElementById('boroSelect').value;
//     var currentBorough = document.getElementById('boroSelect').getAttribute('data-current');

//     if (selectedBorough === currentBorough) {
//         return;
//     }

//     clearPlantedTrees();
//     clearMapLayers();

//     document.getElementById('boroSelect').setAttribute('data-current', selectedBorough);

//     $.getJSON('./boros/boro_cd_' + selectedBorough + '.geojson', function(data) {
//         originalGeoJsonData = data;
//         calculateMinMaxMean(originalGeoJsonData);
//         displayGeoJson(originalGeoJsonData);
//         updatePlantableAreaColors();
//         zoomToBorough(data);
//     });

//     $.getJSON('./borosSchools/boro_cd_' + selectedBorough + '.geojson', function(data) {
//         map.setLayoutProperty('schoolLayer', 'visibility', 'none');
//         map.getSource('schoolLayer').setData(data);
//         if (document.getElementById('schoolToggleView').checked) {
//             createSchoolCircles(data);
//         }
//     });
// }



        loadBoroughOptions();

        document.getElementById('boroSelect').addEventListener('change', switchBorough);
    </script>
</body>
</html>
