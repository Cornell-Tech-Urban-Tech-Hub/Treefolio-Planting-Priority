<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Planting Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.1/css/all.css">
    <style>
        body {
            display: flex;
            font-family: 'Arial', sans-serif;
            margin:0px;
        }
        #sidebar {
            width: 300px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: #f4f4f4;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        #map {
            height: 100vh;
            flex-grow: 1;
        }
        .input-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
        }
        .input-group label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        button {
            margin-top:10px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #45a049;
        }



        /* Style for the custom checkbox */
.custom-checkbox {
    display: inline-block;
    position: relative;
    padding-left: 25px;
    cursor: pointer;
    font-size: 16px;
    line-height: 20px;
    user-select: none;
}

/* Hide the default checkbox */
.custom-checkbox input {
    position: absolute;
    opacity: 0;
    cursor: pointer;
    height: 0;
    width: 0;
}

/* Create a custom checkbox */
.checkmark {
    position: absolute;
    top: 0;
    left: 0;
    height: 20px;
    width: 20px;
    background-color: #eee;
    border-radius: 4px;
}

/* When the checkbox is checked, add a blue background */
.custom-checkbox input:checked ~ .checkmark {
    background-color: #2196F3;
}

/* Create the checkmark/indicator (hidden when not checked) */
.checkmark:after {
    content: "\f00c"; /* Correct code for FontAwesome checkmark */
    font-family: "Font Awesome 5 Free";
    font-weight: 900; /* FontAwesome 5 requires explicit font-weight for solid icons */
    position: absolute;
    display: none;
    color: white;
    top: -2px;
    left: 5px;
    font-size: 14px;
}

/* Show the checkmark when checked */
.custom-checkbox input:checked ~ .checkmark:after {
    display: block;
}

/* Style the checkmark/indicator */
.custom-checkbox .checkmark:after {
    left: 5px;
    top: 0px;
}




    </style>
</head>
<body>

    <div id="sidebar">
        <h2><i class="fas fa-tree"></i> Tree Planting Parameters</h2>
        <form id="parametersForm">
            <div class="input-group">
                <label for="totalTrees">Total Trees:</label>
                <input type="number" id="totalTrees" name="totalTrees" value="1000">
            </div>
            <div class="input-group">
                <label for="coolingEffect">Cooling Effect:</label>
                <input type="number" id="coolingEffect" name="coolingEffect" step="0.1" value="0.1">
            </div>
            <div class="input-group">
                <label for="coolingDistance">Cooling Distance (meters):</label>
                <input type="number" id="coolingDistance" name="coolingDistance" value="50000">
            </div>
            <button type="button" onclick="updateTreePlanting()">Update Tree Planting</button>
            <h4 id="results">...</h4>


            <div class="input-group">
                <label>Effect Type:</label>
                <label><input type="radio" name="effectType" value="binary" onchange="toggleGaussianSettings()" checked> Binary</label>
                <label><input type="radio" name="effectType" value="gaussian" onchange="toggleGaussianSettings()"> Gaussian</label>
            </div>
            <div id="gaussianSettings" style="display: none;">
                <div class="input-group">
                    <label for="gaussianSigma">Gaussian Sigma:</label>
                    <input type="number" id="gaussianSigma" name="gaussianSigma" step="0.1" value="1">
                </div>
                <div class="input-group">
                    <label for="gaussianAmplitude">Gaussian Amplitude:</label>
                    <input type="number" id="gaussianAmplitude" name="gaussianAmplitude" step="0.1" value="1">
                </div>
            </div>

            <label class="custom-checkbox">Show Heat Index
                <input type="checkbox" id="heatIndexToggle" name="heatIndexToggle" onchange="toggleHeatIndex()">
                <span class="checkmark"></span>
            </label>
            <div id="heatIndexSettings" style="display: none;">
                <div class="input-group">
                    <label for="heatIndexScale">Heat Index Scale:</label>
                    <input type="range" id="heatIndexScale" name="heatIndexScale" min="0.1" max="10" step="0.1" value="1">
                </div>
            </div>

            <!-- Tree Data Toggle and Settings -->
            <label class="custom-checkbox">View Tree Data
                <input type="checkbox" id="treeToggleView" name="treeToggleView" onchange="toggleTreeSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="treeSettings" style="display: none;">
                <div class="input-group">
                    <label for="treeCoolingEffect">Tree Cooling Effect:</label>
                    <input type="number" id="treeCoolingEffect" name="treeCoolingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="treeCoolingDistance">Tree Cooling Distance (meters):</label>
                    <input type="number" id="treeCoolingDistance" name="treeCoolingDistance" value="500">
                </div>
            </div>

            <!-- School Data Toggle and Settings -->
            <label class="custom-checkbox">View School Data
                <input type="checkbox" id="schoolToggleView" name="schoolToggleView" onchange="toggleSchoolSettings()">
                <span class="checkmark"></span>
            </label>
            <div id="schoolSettings" style="display: none;">
                <label class="custom-checkbox">Show School Radius
                    <input type="checkbox" id="schoolRadiusToggle" name="schoolRadiusToggle" onchange="toggleSchoolRadius()" checked>
                    <span class="checkmark"></span>
                </label>
                <div class="input-group">
                    <label for="schoolHeatingEffect">School Heating Effect:</label>
                    <input type="number" id="schoolHeatingEffect" name="schoolHeatingEffect" step="0.1" value="0.1">
                </div>
                <div class="input-group">
                    <label for="schoolHeatingDistance">School Heating Distance (meters):</label>
                    <input type="number" id="schoolHeatingDistance" name="schoolHeatingDistance" value="500">
                </div>
            </div>

            
        </form>
    </div>
    
    <div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-geometryutil@0.10.1/src/leaflet.geometryutil.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script>
    var map = L.map('map',
    {
        renderer: L.canvas() // Set Canvas as the default renderer for all layers
    }).setView([40.642935, -73.930188], 13); 

    // L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    //     attribution: '© OpenStreetMap contributors'
    // }).addTo(map);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/light_all/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors, © CartoDB'
    }).addTo(map);



    // Global variable to keep track of the current GeoJSON layer
    var currentGeoJsonLayer = null;

    function displayGeoJson(geojsonData) {
        if (currentGeoJsonLayer) {
            map.removeLayer(currentGeoJsonLayer);
        }

        currentGeoJsonLayer = L.geoJson(geojsonData, {
            style: function(feature) {
                // try by color
                return { color: feature.properties.color, weight: 2, fillOpacity: 0.5 };
                // return { color: getColor(feature.properties._mean, heatIndexScale), weight: 2, fillOpacity: 0.5 };
            }
        }).addTo(map);
    }

//     function displayGeoJson(geojsonData) {
//     if (currentGeoJsonLayer) {
//         map.removeLayer(currentGeoJsonLayer);
//     }

//     currentGeoJsonLayer = L.geoJson(geojsonData, {
//         style: function(feature) {
//             // Generate a random color for each plantable area
//             const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16);
//             return { color: randomColor, weight: 2, fillOpacity: 0.5 };
//         },
//         onEachFeature: function(feature, layer) {
//             if (feature.properties.canopy_typ === 'plantable') {
//                 const centroid = calculateCentroid(feature.geometry);
//                 const marker = L.marker(centroid, {
//                     icon: L.divIcon({
//                         className: 'centroid-marker',
//                         html: '<div style="background-color: red; width: 10px; height: 10px; border-radius: 50%;"></div>',
//                         iconSize: [10, 10]
//                     })
//                 }).addTo(map);
//             }
//         }
//     }).addTo(map);
// }


    function displayHeatIndexGeoJson(geojsonData, heatIndexScale) {
        if (currentGeoJsonLayer) {
            map.removeLayer(currentGeoJsonLayer);
        }

        currentGeoJsonLayer = L.geoJson(geojsonData, {
            style: function(feature) {
                return { color: getColor(feature.properties._mean, heatIndexScale), weight: 2, fillOpacity: 0.5 };
            }
        }).addTo(map);
    }


    function updateTreePlanting() {
        var totalTrees = parseInt(document.getElementById('totalTrees').value);
        var coolingEffect = parseFloat(document.getElementById('coolingEffect').value);
        var coolingDistance = parseInt(document.getElementById('coolingDistance').value);

        // Clear existing tree markers
        clearMapLayers();
        
        // Example values for schoolEffect and schoolDistance, replace with actual input retrieval
        let schoolEffect = parseFloat(document.getElementById('schoolHeatingEffect').value);
        let schoolDistance = parseInt(document.getElementById('schoolHeatingDistance').value);

        // Example values for treeEffect and treeDistance, replace with actual input retrieval
        let treeEffect = parseFloat(document.getElementById('treeCoolingEffect').value);
        let treeDistance = parseInt(document.getElementById('treeCoolingDistance').value);

        // Pass the additional parameters for schools and trees to the planting function
        PlantTrees(originalGeoJsonData, totalTrees, coolingEffect, coolingDistance, schoolEffect, schoolDistance, treeEffect, treeDistance);


    }

    function clearMapLayers() {
        // Modified to remove only tree markers, preserving the GeoJSON layer
        map.eachLayer(function(layer) {
            if (layer instanceof L.Marker) {
                map.removeLayer(layer);
            }
        });
    }

    function calculateCentroid(geometry) {
    let centroid = [0, 0];
    let totalPoints = 0;

    if (geometry.type === "Polygon") {
        geometry.coordinates[0].forEach(coord => {
            centroid[0] += coord[0]; // longitude
            centroid[1] += coord[1]; // latitude
            totalPoints++;
        });
    } else if (geometry.type === "MultiPolygon") {
        geometry.coordinates.forEach(polygon => {
            let polygonCentroid = [0, 0];
            let polygonPoints = 0;
            polygon[0].forEach(coord => { // Only using the first ring
                polygonCentroid[0] += coord[0];
                polygonCentroid[1] += coord[1];
                polygonPoints++;
            });
            centroid[0] += polygonCentroid[0] / polygonPoints; // Average for this polygon
            centroid[1] += polygonCentroid[1] / polygonPoints;
            totalPoints += 1; // We're averaging centroids, so each polygon counts as one "point"
        });
    }

    centroid[0] /= totalPoints; // Final average
    centroid[1] /= totalPoints;
    return [centroid[1], centroid[0]]; // Leaflet uses [lat, lng] format
}





function PlantTrees(originalGeoJsonData, totalTrees, coolingEffect, coolingDistance, schoolEffect, schoolDistance, treeEffect, treeDistance) {
    let geojsonData = JSON.parse(JSON.stringify(originalGeoJsonData));
    let plantableAreas = geojsonData.features.filter(feature => feature.properties.canopy_typ === 'plantable');

    // Apply effects from schools and existing trees
    applySchoolEffect(plantableAreas, schoolEffect, schoolDistance);
    applyTreeEffect(plantableAreas, treeEffect, treeDistance);

    let treesPlanted = 0;

    while (treesPlanted < totalTrees && plantableAreas.length > 0) {
        // Calculate the combined mean for each plantable area
        plantableAreas.forEach(area => {
            area.properties._combinedMean = (area.properties._mean || 0) + (area.properties._heatIndex || 0) + (area.properties._schoolmean || 0) + (area.properties._treemean || 0);
        });

        // Sort plantable areas by _combinedMean property in descending order
        plantableAreas.sort((a, b) => b.properties._combinedMean - a.properties._combinedMean);

        const plantingArea = plantableAreas[0];

        const centroid = calculateCentroid(plantingArea.geometry);
        placeTreeOnMap(centroid);
        treesPlanted++;

        // Apply cooling effect to the planted area if applicable
        if (coolingEffect > 0) {
            plantingArea.properties._treemean = (plantingArea.properties._treemean || 0) - coolingEffect;
        }

        // Filter and adjust remaining plantable areas considering cooling effect and distance
        plantableAreas = plantableAreas.slice(1).filter(area => {
            const areaCentroid = calculateCentroid(area.geometry);
            const distance = getDistance(centroid[0], centroid[1], areaCentroid[0], areaCentroid[1]);
            if (coolingDistance > 0 && distance <= coolingDistance && coolingEffect > 0) {
                area.properties._treemean = (area.properties._treemean || 0) - coolingEffect * (coolingDistance - distance) / coolingDistance;
            }
            return area.properties._combinedMean > 0;
        });
    }

    if (treesPlanted < totalTrees) {
        console.log(`Planted ${treesPlanted} trees. Ran out of suitable planting areas.`);
        document.getElementById('results').innerText = `Planted ${treesPlanted} trees. Ran out of suitable planting areas.`;
    } else {
        console.log(`Successfully planted all ${totalTrees} trees.`);
        document.getElementById('results').innerText = `Successfully planted all ${totalTrees} trees.`;
    }
}





    function placeTreeOnMap(centroid) {
        L.marker(centroid).addTo(map);
    }

    function getDistance(lat1, lon1, lat2, lon2) {
        // Haversine formula to calculate distance between two points on Earth
        var R = 6371e3; // Earth's radius in meters
        var φ1 = lat1 * Math.PI / 180;
        var φ2 = lat2 * Math.PI / 180;
        var Δφ = (lat2 - lat1) * Math.PI / 180;
        var Δλ = (lon2 - lon1) * Math.PI / 180;

        var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c; // in meters
    }

    // function getDistance(lat1, lon1, lat2, lon2) {
    //     // Euclidean distance between two points on Earth
    //     var x = (lon2 - lon1) * Math.cos((lat1 + lat2) / 2);
    //     var y = (lat2 - lat1);
    //     return Math.sqrt(x * x + y * y); // in meters
    // }



    function getColor(heatIndex, scale) {
        console.log("max and min mean", maxMean, minMean);
        const range = maxMean - minMean;
        const normalizedIndex = (heatIndex - minMean) / range;
        const scaledIndex = Math.pow(normalizedIndex, scale);

        // Interpolate between green (0), orange (0.5), and red (1)
        if (scaledIndex < 0.5) {
            // Mix between green and orange
            const mix = scaledIndex * 2;
            return mixColor('#008000', '#ff8c00', mix);
        } else {
            // Mix between orange and red
            const mix = (scaledIndex - 0.5) * 2;
            return mixColor('#ff8c00', '#ff0000', mix);
        }
    }

    var showHeatIndex = false;
    var heatIndexScale = 1;

    function toggleHeatIndex() {
        showHeatIndex = document.getElementById('heatIndexToggle').checked;
        document.getElementById('heatIndexSettings').style.display = showHeatIndex ? 'block' : 'none';
        updateHeatIndexScale();
    }

    function updateHeatIndexScale() {
        heatIndexScale = parseFloat(document.getElementById('heatIndexScale').value);
        if (showHeatIndex) {
            // calculateMinMaxMean(originalGeoJsonData)
            // displayHeatIndexGeoJson(originalGeoJsonData, heatIndexScale);
            displayGeoJson(originalGeoJsonData);
        } else {
            // calculateMinMaxMean(originalGeoJsonData)
            displayGeoJson(originalGeoJsonData);
        }
    }

    function mixColor(color1, color2, weight) {
        var color1Rgb = hexToRgb(color1),
            color2Rgb = hexToRgb(color2),
            r = Math.round(mix(color1Rgb.r, color2Rgb.r, weight)),
            g = Math.round(mix(color1Rgb.g, color2Rgb.g, weight)),
            b = Math.round(mix(color1Rgb.b, color2Rgb.b, weight));
        return rgbToHex(r, g, b);
    }

    function mix(start, end, weight) {
        return start + (end - start) * weight;
    }

    function hexToRgb(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    function rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }


    var originalGeoJsonData;

    var minMean, maxMean;

    function calculateMinMaxMean(geojsonData) {

        // check what features are enabled and calculate min and max mean
        treemean = [];
        schoolmean = [];
        heatmean = [];
        if(document.getElementById('treeToggleView').checked) {
            treemean = geojsonData.features.map(feature => feature.properties._treeindex);
        }
        if(document.getElementById('schoolToggleView').checked) {
            schoolmean = geojsonData.features.map(feature => feature.properties._schoolmean);
        }
        if(document.getElementById('heatIndexToggle').checked) {
            heatmean = geojsonData.features.map(feature => feature.properties._mean);
        }

        means = treemean.concat(schoolmean, heatmean);
        console.log(means);
        // cast out the undefined values
        means = means.filter(function (el) {
            return el != null;
        });

        // const means = geojsonData.features.map(feature => feature.properties.);
        minMean = Math.min(...means);
        maxMean = Math.max(...means);
        if (minMean === maxMean) {
            minMean = 0;
            maxMean = 1;
        }
        // if infinity
        if (minMean === Infinity) {
            minMean = 0;
            maxMean = 1;
        }
        console.log("Calculated min and max mean values:", minMean, maxMean);
    }

    $.getJSON('inputStreet.geojson', function(data) {
        originalGeoJsonData = data;
        calculateMinMaxMean(originalGeoJsonData); // Calculate min and max mean values
        // displayGeoJson(originalGeoJsonData, showHeatIndex, heatIndexScale);
        displayGeoJson(originalGeoJsonData);


        $.getJSON('schoolsBK17.geojson', function(data) {
        L.geoJson(data).eachLayer(function(layer) {
            schoolLayer.addLayer(layer); // This should add each school to the schoolLayer
        });
        console.log(schoolLayer.getLayers().length); // This should now log a non-zero number
        // drawLinesToSchoolsWithinRadius();
    });


    });



function drawLinesToClosestSchoolFromLayer() {
    originalGeoJsonData.features.forEach(plantableArea => {
        if (plantableArea.properties.canopy_typ === 'plantable') {
            const plantableCentroid = calculateCentroid(plantableArea.geometry);

            let closestSchoolPoint = null;
            let minDistance = Infinity;

            console.log(schoolLayer);
            // log the length of the schoolLayer to ensure it's not empty
            console.log(schoolLayer.getLayers().length);

            schoolLayer.eachLayer(function(layer) {
            let schoolPoint;
            if (layer.feature && layer.feature.geometry) {
                // Handle MultiPoint geometry
                if (layer.feature.geometry.type === 'MultiPoint') {
                    // Assuming we're interested in the first point of the MultiPoint
                    const firstPointCoords = layer.feature.geometry.coordinates[0];
                    schoolPoint = [firstPointCoords[1], firstPointCoords[0]]; // Correct [lat, lng] order for Leaflet
                } else {
                    // For simplicity, handling other types as before (assuming Point)
                    schoolPoint = [layer.feature.geometry.coordinates[1], layer.feature.geometry.coordinates[0]];
                }
            } else if (layer.getLatLng) {
                // This is for layers that are not GeoJSON (e.g., L.Marker, L.CircleMarker)
                let latLng = layer.getLatLng();
                schoolPoint = [latLng.lat, latLng.lng]; // Leaflet uses [lat, lng]
            } else {
                console.log('Unknown layer type or geometry not defined');
                return; // Skip this layer if it doesn't have recognizable geometry
            }

            // Calculate distance (ensure your getDistance function is using the correct coordinate order)
            const distance = getDistance(plantableCentroid[0], plantableCentroid[1], schoolPoint[0], schoolPoint[1]);
            console.log(plantableCentroid);
            console.log(schoolPoint);
            console.log(distance);
            if (distance < minDistance) {

                closestSchoolPoint = schoolPoint;
                minDistance = distance;
            }
        });


        // When adding to map, ensure closestSchoolPoint is correctly structured
        if (closestSchoolPoint) {
            L.polyline([
                // [plantableCentroid[1], plantableCentroid[0]],
                [plantableCentroid[0], plantableCentroid[1]],
                closestSchoolPoint // This should be [lat, lng]
            ], {
                color: 'blue',
                weight: 1,
                opacity: 0.5
            }).addTo(map);
        }


        }
    });
}

function drawLinesToSchoolsWithinRadius() {
    const radius = 1000; // Define your radius in meters

    originalGeoJsonData.features.forEach(plantableArea => {
        if (plantableArea.properties.canopy_typ === 'plantable') {
            const plantableCentroid = calculateCentroid(plantableArea.geometry);

            // No longer keeping track of the closest school or minimum distance
            console.log(schoolLayer);
            console.log(schoolLayer.getLayers().length);

            schoolLayer.eachLayer(function(layer) {
                let schoolPoint;
                if (layer.feature && layer.feature.geometry) {
                    // Handle MultiPoint geometry
                    if (layer.feature.geometry.type === 'MultiPoint') {
                        const firstPointCoords = layer.feature.geometry.coordinates[0];
                        schoolPoint = [firstPointCoords[1], firstPointCoords[0]]; // [lat, lng] order for Leaflet
                    } else {
                        // For simplicity, handling other types as before (assuming Point)
                        schoolPoint = [layer.feature.geometry.coordinates[1], layer.feature.geometry.coordinates[0]];
                    }
                } else if (layer.getLatLng) {
                    // This is for layers that are not GeoJSON (e.g., L.Marker, L.CircleMarker)
                    let latLng = layer.getLatLng();
                    schoolPoint = [latLng.lat, latLng.lng]; // Leaflet uses [lat, lng]
                } else {
                    console.log('Unknown layer type or geometry not defined');
                    return; // Skip this layer if it doesn't have recognizable geometry
                }

                // Calculate distance
                const distance = getDistance(plantableCentroid[0], plantableCentroid[1], schoolPoint[0], schoolPoint[1]);
                console.log(plantableCentroid);
                console.log(schoolPoint);
                console.log(distance);
                // Draw line if within the specified radius
                if (distance <= radius) {
                    L.polyline([
                        [plantableCentroid[0], plantableCentroid[1]],
                        schoolPoint // [lat, lng] order
                    ], {
                        color: 'blue',
                        weight: 1,
                        opacity: 0.5
                    }).addTo(map);
                }
            });
        }
    });
}


function loadSchoolDataAndDrawLines() {
    $.getJSON('schoolsBK17.geojson', function(data) {
        // Assuming this is where you add schools to schoolLayer
        L.geoJson(data, {
            onEachFeature: function(feature, layer) {
                schoolLayer.addLayer(layer);
            }
        });
        // After adding schools to schoolLayer, now draw lines
        // drawLinesToClosestSchoolFromLayer();
    });
}


// Call this function after your map and datasets have been initialized
// drawLinesToClosestSchoolFromLayer();


    var treeLayer = L.layerGroup(); // Initialize with an empty layer group
    var schoolLayer = L.layerGroup(); // Initialize with an empty layer group

    // Function to toggle Tree Data
    function toggleTreeData() {
        var treeDataVisible = document.getElementById('treeToggleView').checked;
        if (treeDataVisible) {
            if (!map.hasLayer(treeLayer)) {
                $.getJSON('treefolio84.geojson', function(data) {
                    treeLayer = L.geoJson(data, {
                        pointToLayer: function(feature, latlng) {
                            return L.circle(latlng, {radius: 8, fillColor: "#228B22", color: "#228B22", weight: 3, opacity: 1, fillOpacity: 0.8});
                        }
                    }).addTo(map);
                });
            }
        } else {
            if (treeLayer) map.removeLayer(treeLayer);
        }
    }

    var schoolCircles = [];

    // Function to toggle School Data and draw initial heating circles
    function toggleSchoolData() {
        var schoolDataVisible = document.getElementById('schoolToggleView').checked;
        if (schoolDataVisible) {
            if (!map.hasLayer(schoolLayer)) {
                $.getJSON('schoolsBK17.geojson', function(data) {
                    schoolLayer = L.geoJson(data, {
                        pointToLayer: function(feature, latlng) {
                            // Original school circle marker
                            var originalCircle = L.circleMarker(latlng, {
                                radius: 8,
                                fillColor: "#ff7800",
                                color: "#000",
                                weight: 3,
                                opacity: 1,
                                fillOpacity: 0.8
                            });

                            // Additional circle for heating distance
                            var heatingDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
                            var effectType = document.querySelector('input[name="effectType"]:checked').value;
                            var effectCircle;

                            if (effectType === 'binary') {
                                effectCircle = L.circle(latlng, {
                                    color: 'red',
                                    // fillColor: '#f03',
                                    fillOpacity: 0,
                                    radius: heatingDistance
                                });
                                schoolCircles.push(effectCircle);
                                effectCircle.addTo(map);    
                                originalCircle._heatingCircle = effectCircle;
                            } else if (effectType === 'gaussian') {
                                effectCircle = L.circle(latlng, {
                                    color: 'blue',
                                    // fillColor: '#b0e0e6',
                                    // fillOpacity: 0.2,
                                    radius: heatingDistance,
                                    interactive: false
                                });
                                schoolCircles.push(effectCircle);
                                effectCircle.addTo(map);
                                originalCircle._gaussianCircle = effectCircle;
                            }

                            // Group both circles to handle them together
                            var group = L.layerGroup([originalCircle]).addTo(map);
                            return group;
                        }
                    }).addTo(map);
                });
            }
            // drawLinesToClosestSchoolWithinRadius();
        } else {
            if (schoolLayer) {
                map.removeLayer(schoolLayer);
                // remove 
                schoolCircles.forEach(circle => map.removeLayer(circle));
                // reset the plantable area colors
                updatePlantableAreaColors();

            }
        }
    }


    // Function to toggle tree settings visibility
    function toggleTreeSettings() {
        toggleTreeData();
        var treeSettings = document.getElementById('treeSettings');
        var treeToggle = document.getElementById('treeToggleView').checked;
        treeSettings.style.display = treeToggle ? "block" : "none";
    }

    // Function to toggle school settings visibility
    function toggleSchoolSettings() {
        toggleSchoolData();
        var schoolSettings = document.getElementById('schoolSettings');
        var schoolToggle = document.getElementById('schoolToggleView').checked;
        schoolSettings.style.display = schoolToggle ? "block" : "none";
    }

    function toggleGaussianSettings() {
        var effectType = document.querySelector('input[name="effectType"]:checked').value;
        var gaussianSettings = document.getElementById('gaussianSettings');
        gaussianSettings.style.display = effectType === 'gaussian' ? 'block' : 'none';
    }

    function gaussianWeight(distance, effectDistance, sigma, amplitude) {
        var z = distance / (effectDistance * sigma);
        return amplitude * Math.exp(-0.5 * z * z);
    }


    function applySchoolEffect(geojsonData, schoolEffect, schoolDistance) {

    // If view school data isn't checked, return the original geojson data
    if (!document.getElementById('schoolToggleView').checked) {
        console.log('School data not visible, returning original geojson data');
        return geojsonData;
    }

    var effectType = document.querySelector('input[name="effectType"]:checked').value;
    var sigma = parseFloat(document.getElementById('gaussianSigma').value);
    var amplitude = parseFloat(document.getElementById('gaussianAmplitude').value);

    geojsonData.features.forEach(plantableArea => {
        if (plantableArea.properties.canopy_typ === 'plantable') {
            const plantableCentroid = calculateCentroid(plantableArea.geometry);

            schoolLayer.eachLayer(function(layer) {
                let schoolPoint;
                if (layer.feature && layer.feature.geometry) {
                    if (layer.feature.geometry.type === 'MultiPoint') {
                        const firstPointCoords = layer.feature.geometry.coordinates[0];
                        schoolPoint = [firstPointCoords[1], firstPointCoords[0]];
                    } else {
                        schoolPoint = [layer.feature.geometry.coordinates[1], layer.feature.geometry.coordinates[0]];
                    }
                } else if (layer.getLatLng) {
                    let latLng = layer.getLatLng();
                    schoolPoint = [latLng.lat, latLng.lng];
                } else {
                    console.log('Unknown layer type or geometry not defined');
                    return;
                }

                const distance = getDistance(plantableCentroid[0], plantableCentroid[1], schoolPoint[0], schoolPoint[1]);
                if (effectType === 'binary') {
                    if (distance <= schoolDistance) {
                        console.log("Applying binary school effect");
                        console.log("Distance:", schoolEffect);
                        if(!plantableArea.properties._schoolmean) {
                            plantableArea.properties._schoolmean = 0;
                        }                        
                        plantableArea.properties._schoolmean += schoolEffect;
                        console.log("School mean:", plantableArea.properties._schoolmean);
                    }
                } else if (effectType === 'gaussian') {
                    var weight = gaussianWeight(distance, schoolDistance, sigma, amplitude);
                    if(!plantableArea.properties._schoolmean) {
                        plantableArea.properties._schoolmean = 0;
                    }
                    plantableArea.properties._schoolmean += schoolEffect * weight;
                }
            });
        }
    });
    return geojsonData;
}

    // function updatePlantableAreaColors() {
    //     let geojsonData = JSON.parse(JSON.stringify(originalGeoJsonData));

    //     // Reset the _mean values to the original values
    //     geojsonData.features.forEach(feature => {
    //         if (feature.properties.canopy_typ === 'plantable') {
    //             feature.properties._mean = originalGeoJsonData.features.find(f => f.properties.treeindex === feature.properties.treeindex).properties._mean;
    //         }
    //     });




    //     let schoolEffect = parseFloat(document.getElementById('schoolHeatingEffect').value);
    //     let schoolDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
    //     let treeEffect = parseFloat(document.getElementById('treeCoolingEffect').value);
    //     let treeDistance = parseInt(document.getElementById('treeCoolingDistance').value);

    //     geojsonData = applySchoolEffect(geojsonData, schoolEffect, schoolDistance);
    //     geojsonData = applyTreeEffect(geojsonData, treeEffect, treeDistance);

    //     calculateMinMaxMean(geojsonData);
    //     updateMeanColors(geojsonData);
    //     displayGeoJson(geojsonData);
    // }


    function updatePlantableAreaColors() {
    let geojsonData = JSON.parse(JSON.stringify(originalGeoJsonData));

    // Reset _mean values to 0
    geojsonData.features.forEach(feature => {
        if (feature.properties.canopy_typ === 'plantable') {
            feature.properties._heatIndex = 0;
            feature.properties._displayMean = 0;
            // reset color
            feature.properties.color = '#008000';
            // feature.properties._mean = 0;
        }
    });

    // Apply heat index effect
    var heatIndexToggle = document.getElementById('heatIndexToggle').checked;
    var heatIndexScale = parseFloat(document.getElementById('heatIndexScale').value);
    if (heatIndexToggle) {
        console.log("Applying heat index effect");
        geojsonData.features.forEach(feature => {
            if (feature.properties.canopy_typ === 'plantable') {
                const heatIndex = getHeatIndex(feature.properties._mean, heatIndexScale);
                // feature.properties._heatIndex = heatIndex;
            }
        });
    } 

    let schoolEffect = parseFloat(document.getElementById('schoolHeatingEffect').value);
    let schoolDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
    let treeEffect = parseFloat(document.getElementById('treeCoolingEffect').value);
    let treeDistance = parseInt(document.getElementById('treeCoolingDistance').value);

    // Apply school effect
    geojsonData = applySchoolEffect(geojsonData, schoolEffect, schoolDistance);

    // Apply tree effect
    geojsonData = applyTreeEffect(geojsonData, treeEffect, treeDistance);

    // Combine heat index and school/tree effects
    geojsonData.features.forEach(feature => {
        if (feature.properties.canopy_typ === 'plantable') {
            if(heatIndexToggle) {
                feature.properties._displayMean = feature.properties._mean + (feature.properties._heatIndex || 0) + (feature.properties._schoolmean || 0);
            } else {
                console.log("schoolmean", feature.properties._schoolmean);
                // If heat index is not applied, only use the original _mean value (without heat index effect
                feature.properties._displayMean = (feature.properties._heatIndex || 0) + (feature.properties._schoolmean || 0);
            }
        }
    });

    calculateMinMaxMean(geojsonData);
    updateMeanColors(geojsonData);
    displayGeoJson(geojsonData);
}
function getHeatIndex(mean, scale) {
    const range = maxMean - minMean;
    const normalizedIndex = (mean - minMean) / range;
    const scaledIndex = Math.pow(normalizedIndex, scale);
    return scaledIndex;
}


    function getMeanColor(mean) {
    // Use the global minMean and maxMean values
    const normalizedMean = (mean - minMean) / (maxMean - minMean);

    // Interpolate between green (0), orange (0.5), and red (1)
    if (normalizedMean < 0.5) {
        // Mix between green and orange
        const mix = normalizedMean * 2;
        return mixColor('#008000', '#ff8c00', mix);
    } else {
        // Mix between orange and red
        const mix = (normalizedMean - 0.5) * 2;
        return mixColor('#ff8c00', '#ff0000', mix);
    }
}


function updateMeanColors(geojsonData) {
    geojsonData.features.forEach(feature => {
        if (feature.properties.canopy_typ === 'plantable') {
            const mean = feature.properties._displayMean;
            console.log("Getting mean color for:", mean);
            feature.properties.color = getMeanColor(mean);
        }
    });
}


    function getBoundingBox(centerPoint, distance) {
        var latRadian = centerPoint[0] * Math.PI / 180;

        var degLatKm = 110.574235;
        var degLongKm = 110.572833 * Math.cos(latRadian);
        var deltaLat = distance / 1000.0 / degLatKm;
        var deltaLong = distance / 1000.0 / degLongKm;

        return {
            minLat: centerPoint[0] - deltaLat,
            maxLat: centerPoint[0] + deltaLat,
            minLng: centerPoint[1] - deltaLong,
            maxLng: centerPoint[1] + deltaLong
        };
    }

    function isPointInBoundingBox(point, bbox) {
        return point[0] >= bbox.minLat && point[0] <= bbox.maxLat &&
            point[1] >= bbox.minLng && point[1] <= bbox.maxLng;
    }
    function applyTreeEffect(geojsonData, treeEffect, treeDistance) {
    var effectType = document.querySelector('input[name="effectType"]:checked').value;
    var sigma = parseFloat(document.getElementById('gaussianSigma').value);

    treeLayer.eachLayer(function(treeFeatureLayer) {
        const treePoint = [treeFeatureLayer.feature.geometry.coordinates[1], treeFeatureLayer.feature.geometry.coordinates[0]];

        geojsonData.features.forEach(feature => {
            if (feature.properties.canopy_typ === 'plantable') {
                const areaCentroid = calculateCentroid(feature.geometry);
                const distance = getDistance(areaCentroid[0], areaCentroid[1], treePoint[0], treePoint[1]);

                if (effectType === 'binary') {
                    if (distance <= treeDistance) {
                        feature.properties._mean -= treeEffect;
                    }
                } else if (effectType === 'gaussian') {
                    var weight = gaussianWeight(distance, treeDistance, sigma);
                    feature.properties._mean -= treeEffect * weight;
                }
            }
        });
    });
    return geojsonData;
}



    var heatingCircles = []; // Array to keep track of heating circles


    function updateSchoolHeatingDistance() {
        // Remove existing school layers
        schoolCircles.forEach(circle => map.removeLayer(circle));
        if (map.hasLayer(schoolLayer)) {
            map.removeLayer(schoolLayer);
        }
        toggleSchoolData();
    }



    function clearSchoolHeatingCircles() {
        // Remove existing heating circles
        schoolLayer.eachLayer(function(layer) {
            if (layer._heatingCircle) {
                map.removeLayer(layer._heatingCircle);
                delete layer._heatingCircle; // Clean up reference to the removed circle
            }
        });
    }


    function changeEffectType() {
        var effectType = document.querySelector('input[name="effectType"]:checked').value;
        if (effectType === 'binary') {
            // Remove Gaussian circles and revert to binary circles
            schoolLayer.eachLayer(function(layer) {
                layer.eachLayer(function(sublayer) {
                    if (sublayer._gaussianCircle) {
                        map.removeLayer(sublayer._gaussianCircle);
                        delete sublayer._gaussianCircle;
                    }
                    if (sublayer instanceof L.CircleMarker && !sublayer._heatingCircle) {
                        var latlng = sublayer.getLatLng();
                        var heatingDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
                        var heatingCircle = L.circle(latlng, {
                            color: 'red',
                            fillColor: '#f03',
                            fillOpacity: 0.2,
                            radius: heatingDistance
                        }).addTo(map);
                        sublayer._heatingCircle = heatingCircle;
                    }
                });
            });
        } else if (effectType === 'gaussian') {
            // Remove binary circles and add Gaussian circles
            schoolLayer.eachLayer(function(layer) {
                layer.eachLayer(function(sublayer) {
                    if (sublayer._heatingCircle) {
                        map.removeLayer(sublayer._heatingCircle);
                        delete sublayer._heatingCircle;
                    }
                    if (sublayer instanceof L.CircleMarker && !sublayer._gaussianCircle) {
                        var latlng = sublayer.getLatLng();
                        var heatingDistance = parseInt(document.getElementById('schoolHeatingDistance').value);
                        var gaussianCircle = L.circle(latlng, {
                            color: 'blue',
                            fillColor: '#b0e0e6',
                            fillOpacity: 0.5,
                            radius: heatingDistance,
                            interactive: false
                        }).addTo(map);
                        sublayer._gaussianCircle = gaussianCircle;
                    }
                });
            });
        }
        // updateHeatIndexScale();
        updatePlantableAreaColors();
    }

    document.getElementById('heatIndexScale').addEventListener('input', updateHeatIndexScale);

    document.querySelectorAll('input[name="effectType"]').forEach(function(radio) {
        radio.addEventListener('change', changeEffectType);
    });

    document.getElementById('treeCoolingEffect').addEventListener('change', updatePlantableAreaColors);
    document.getElementById('treeCoolingDistance').addEventListener('change', updatePlantableAreaColors);

    document.getElementById('gaussianSigma').addEventListener('change', updatePlantableAreaColors);
    document.getElementById('gaussianAmplitude').addEventListener('change', updatePlantableAreaColors);

document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
    document.getElementById('schoolHeatingDistance').addEventListener('change', function() {
        updateSchoolHeatingDistance();
        updatePlantableAreaColors();
    });


document.getElementById('schoolHeatingDistance').addEventListener('change', updatePlantableAreaColors);
document.getElementById('schoolHeatingEffect').addEventListener('change', updatePlantableAreaColors);
document.getElementById('treeCoolingDistance').addEventListener('change', updatePlantableAreaColors);
document.getElementById('treeCoolingEffect').addEventListener('change', updatePlantableAreaColors);
document.getElementById('heatIndexToggle').addEventListener('change', updatePlantableAreaColors);
document.getElementById('heatIndexScale').addEventListener('input', updatePlantableAreaColors);
document.getElementById('schoolToggleView').addEventListener('change', updatePlantableAreaColors);

    function toggleSchoolRadius() {
        var showSchoolRadius = document.getElementById('schoolRadiusToggle').checked;
        schoolCircles.forEach(function(circle) {
            circle.setStyle({ fillOpacity: 0 });
            if (showSchoolRadius) {
                circle.setStyle({ opacity: 1 });
            } else {
                circle.setStyle({ opacity: 0 });
            }
        });
    }


    function toggleTreeRadius() {
    var showTreeRadius = document.getElementById('treeRadiusToggle').checked;
    treeLayer.eachLayer(function(layer) {
        if (layer instanceof L.Circle) {
            layer.setStyle({ fillOpacity: 0 });
            if (showTreeRadius) {
                layer.setStyle({ opacity: 1 });
            } else {
                layer.setStyle({ opacity: 0 });
            }
        }
    });
}

    </script>

</body>
</html>
